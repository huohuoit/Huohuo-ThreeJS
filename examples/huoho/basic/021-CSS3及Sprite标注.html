<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Document</title>
	<style>
		body {
			overflow: hidden;
			margin: 0px;
		}
	</style>
</head>

<body>
	<!-- 注：由于threejs和glft模型加载需要时间，标签对应的HTML/CSS会先显示，这显然是不好的
	 		所以实际开发中，需要先把标签隐藏display: none;，等gltf模型加载完成，HTML元素转化CSS2模型对象以后，再取消HTML隐藏状态
			CSS2渲染器默认会把标签设置为display: block;，这样就不用自己代码恢复HTML标签元素的隐藏状态了
	-->
	<!-- <div id="tag" style="display: none;">标签内容</div> -->

	<!-- backface-visibility: hidden; ———— 禁止CSS3DObject标签对应HTMl元素背面显示 -->
	<div id="tag"
		style="color: red; padding: 2px; background: rgba(255,255,255,0.8); border-radius: 2px; backface-visibility: hidden;">
		标签内容</div>
	<div id="spriteTag">精灵模型</div>
	<script type="importmap">
			{
				"imports": {
					"three": "../../../build/three.module.js",
					"three/addons/": "../../jsm/"
				}
			}
		</script>
	<script type="module">
		/* 
		CSS3DRenderer渲染HTML标签：
			CSS3渲染器CSS3DRenderer和CSS2渲染器CSS2DRenderer整体使用流程基本相同
			HTML标签渲染效果方面不同：如CSS3渲染的标签会跟着场景相机同步缩放，而CSS2渲染的标签默认保持自身像素值
			其HTML标签对象相当于一个矩形平面网格模型Mesh（如：HTML像素高度40px = 高度为40的矩形平面网格模型）
	*/

		import * as THREE from "../../../build/three.module.js";
		import { GUI } from "three/addons/libs/lil-gui.module.min.js";
		import { OrbitControls } from "three/addons/controls/OrbitControls.js";

		import {
			CSS3DRenderer,
			CSS3DObject,
		} from "three/addons/renderers/CSS3DRenderer.js";
		import { CSS3DSprite } from 'three/addons/renderers/CSS3DRenderer.js'; // 引入CSS3精灵模型对象CSS3DSprite

		let gui;

		let camera, scene, renderer, css3Renderer, intersects;

		init();

		function init() {
			// 创建相机
			camera = new THREE.PerspectiveCamera(
				45,
				window.innerWidth / window.innerHeight,
				0.1,
				200
			);
			camera.position.set(100, 100, 100); //根据场景渲染范围尺寸设置相机位置
			camera.lookAt(0, 0, 0);

			// 创建场景
			scene = new THREE.Scene();

			/********************************创建模型-开始********************************/

			// 创建模型
			const geometry = new THREE.ConeGeometry(15, 50);
			const material = new THREE.MeshPhongMaterial({
				color: 0xff0000,
				transparent: true,
				opacity: 0.5
			});
			const mesh = new THREE.Mesh(geometry, material);
			// mesh.position.set(0, 0, 0);

			// 如果需要标注的mesh有多个父对象，且都有自己的位置属性.position，设置mesh标签对象位置CSS3DObject.position的时候，就需要考虑mesh父对象的位置对mesh的影响

			const meshGroup = new THREE.Group(); // mesh设置一个父对象meshGroup
			meshGroup.add(mesh);
			meshGroup.position.x = -10; // // mesh位置受到父对象局部坐标.positionn影响

			scene.add(mesh);

			/* 
				注意：标签<div id="tag"></div>在CSS3渲染器渲染的时候，默认会被设置为pointer-events: auto;
							这时候虽然css3Renderer.domElement不遮挡canvas画布的鼠标事件，但是<div id="tag"></div>会遮挡canvas画布的鼠标事件
				处理：通过代码强制改变CSS3渲染器给标签设置的.style.pointerEvents = 'auto',设置为.style.pointerEvents = 'none'
							修改.style.pointerEvents，要在实例化new CSS3DObject(div)之后，因为执行new CSS3DObject(div)的时候，会把HTML标签设置为.style.pointerEvents = 'auto'
			*/

			// 创建标签模型
			const div = document.getElementById("tag");
			div.style.pointerEvents = 'none';
			const tag = new CSS3DObject(div); // HTML元素转化为threejs的CSS2模型对象
			tag.scale.set(0.5, 0.5, 1);//缩放标签尺寸
			tag.position.y += 50; // 相对父对象局部坐标原点偏移50,刚好标注在圆锥
			mesh.add(tag);
			// 创建CSS3精灵模型
			const divCSS3 = document.getElementById("spriteTag");
			divCSS3.style.pointerEvents = 'none';
			const spriteTag = new CSS3DSprite(divCSS3);
			spriteTag.position.y += 80; // 相对父对象局部坐标原点偏移50,刚好标注在圆锥
			mesh.add(spriteTag);


			// 这里代码块是举例需要作标注的mesh，有多个父对象情况下的处理
			const worldPosition = new THREE.Vector3();
			mesh.getWorldPosition(worldPosition); // 获取mesh的世界坐标(meshGroup.position和mesh.position累加结果)
			tag.position.copy(worldPosition); // mesh世界坐标复制给tag
			const group = new THREE.Group();
			// 最后meshGroup和tag放在同一个父对象中即可
			group.add(meshGroup, tag);
			scene.add(group);

			/********************************创建模型-结束********************************/

			// 添加平行光
			const dirLight = new THREE.DirectionalLight(0xffffff, 1);
			dirLight.position.set(5, 10, 5);
			scene.add(dirLight);

			// 添加辅助坐标系
			const axesHelper = new THREE.AxesHelper(50);
			axesHelper.layers.enableAll();
			scene.add(axesHelper);

			// 添加地面网格并设置颜色
			const gridHelper = new THREE.GridHelper(50, 50, 0x444444, 0x888888);
			scene.add(gridHelper);

			// 创建WebGL渲染器
			renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			// 创建CSS3渲染器 CSS2DRenderer
			css3Renderer = new CSS3DRenderer();
			css3Renderer.setSize(window.innerWidth, window.innerHeight); // 设置标签的尺寸范围，一般和threejs canvas画布宽高度一致即可
			css3Renderer.domElement.style.position = "absolute";
			css3Renderer.domElement.style.top = "0px";
			css3Renderer.domElement.style.left = "0px";
			// 解决HTML元素标签对canvas画布鼠标事件的遮挡问题:会造成相机控件OrbitControls的旋转、缩放等操作无效，也有可能会影响你的射线拾取,等等
			css3Renderer.domElement.style.pointerEvents = "none";
			document.body.appendChild(css3Renderer.domElement);

			// 创建轨道控制器（控制相机,改变相机参数）
			const controls = new OrbitControls(camera, renderer.domElement);
			controls.minDistance = 5;
			controls.maxDistance = 100;
			controls.target.set(0, 0, 0);
			controls.update();

			renderer.render(scene, camera);

			window.addEventListener("resize", onWindowResize);

			initGui();
		}

		function onWindowResize() {
			renderer.setSize(window.innerWidth, window.innerHeight);
			// HTML标签css3Renderer.domElement尺寸重新设置
			css3Renderer.setSize(window.innerWidth, window.innerHeight);
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
		}

		// 执行渲染循环
		function animate() {
			renderer.render(scene, camera);
			css3Renderer.render(scene, camera);
			requestAnimationFrame(animate);
		}
		animate();

		function initGui() {
			gui = new GUI();

			gui.title("初始化GUI");

			// gui.add(layers, 'Toggle Name');
			// ...

			gui.open();
		}
	</script>
</body>

</html>